# -*- coding: utf-8 -*-
"""project_mars.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pwyCHjqA5GzXiGVaSrLVbujajfr51mHt
"""

!pip install --upgrade pip
!pip install streamlit pandas numpy matplotlib seaborn scipy wordcloud streamlit-folium

!pip install konlpy

import streamlit as st
import pandas as pd
import folium
from streamlit_folium import folium_static
from wordcloud import WordCloud
import matplotlib.pyplot as plt
import numpy as np
from folium.plugins import HeatMap
from PIL import Image
import matplotlib.font_manager as fm
from matplotlib.ticker import FuncFormatter
from scipy.stats import pearsonr
from datetime import datetime, timedelta

# --- Colab Environment Setup for Korean Fonts ---
# These commands install Nanum Gothic font and refresh font cache in Colab.
# They need to be run once in the Colab environment.
# Check if font is already installed to avoid unnecessary re-installation
try:
    fm.findfont('NanumGothic', fallback_to_default=False)
    print("NanumGothic font already installed.")
except ValueError:
    print("Installing NanumGothic font...")
    # These commands run on the Colab Linux environment
    !apt-get update -qq
    !apt-get install fonts-nanum -qq
    !fc-cache -fv
    !rm -rf ~/.cache/matplotlib

font_path = '/usr/share/fonts/truetype/nanum/NanumGothic.ttf'
fontprop = fm.FontProperties(fname=font_path, size=10)
plt.rcParams['font.family'] = 'NanumGothic'
plt.rcParams['axes.unicode_minus'] = False

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# import pandas as pd
# import folium
# from streamlit_folium import folium_static, st_folium
# from folium import plugins
# from wordcloud import WordCloud
# import matplotlib.pyplot as plt
# import numpy as np
# from PIL import Image
# import matplotlib.font_manager as fm
# from matplotlib.ticker import FuncFormatter
# from scipy.stats import pearsonr
# from konlpy.tag import Okt
# from collections import Counter
# import time
# import subprocess # This line should be here
# import matplotlib.patches as patches
# import random
# from datetime import datetime, timedelta # datetimeê³¼ timedeltaë¥¼ ì„í¬íŠ¸í•©ë‹ˆë‹¤.
# 
# 
# # --- í˜ì´ì§€ ì„¤ì • ---
# st.set_page_config(
#     page_title="ì „ê¸°ì°¨ ì¸í”„ë¼ ëŒ€ì‹œë³´ë“œ",
#     page_icon="ğŸ”Œ",
#     layout="wide"
# )
# 
# # --- Colab Environment Setup for Korean Fonts (Moved to main for better control) ---
# # This part is now handled within the main() function to ensure it runs once.
# 
# # --- Data Loading and Preprocessing ---
# @st.cache_data
# def load_common_data():
#     """ê³µí†µ ë°ì´í„° ë¡œë“œ ë° ì „ì²˜ë¦¬"""
#     car_path = "ele_car_now_half.csv"
#     charger_path = "ele_car_charger_final.csv"
#     allcar_path = "var_car.csv"
#     crawling_path = "ele_crawling.csv"
#     stopwords_path = "stopwords1.txt"
# 
#     data_dict = {}
# 
#     try:
#         data_dict['df_car'] = pd.read_csv(car_path, encoding='UTF-8')
#         data_dict['df_charger'] = pd.read_csv(charger_path, encoding='UTF-8')
#         data_dict['df_allcar'] = pd.read_csv(allcar_path, encoding='UTF-8')
#         data_dict['df_crawling'] = pd.read_csv(crawling_path, encoding='cp949')
#     except FileNotFoundError as e:
#         st.error(f"ì—ëŸ¬: í•„ìš”í•œ CSV íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ({e})")
#         st.markdown(f"**ë‹¤ìŒ íŒŒì¼ë“¤ì´ Colab í™˜ê²½ì— ì—…ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”:**")
#         st.markdown(f"- `{car_path}`")
#         st.markdown(f"- `{charger_path}`")
#         st.markdown(f"- `{allcar_path}`")
#         st.markdown(f"- `{crawling_path}`")
#         st.markdown(f"- `{stopwords_path}` (ì›Œë“œí´ë¼ìš°ë“œìš©)")
#         st.stop()
#     except Exception as e:
#         st.error(f"ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
#         st.stop()
# 
#     for df_name in ['df_car', 'df_charger', 'df_allcar']:
#         if df_name in data_dict and 'full_date' in data_dict[df_name].columns:
#             data_dict[df_name]['full_date'] = pd.to_datetime(data_dict[df_name]['full_date'])
# 
#     df_ev_chg_merge = pd.merge(data_dict['df_car'][['name', 'full_date', 'year', 'car']],
#                                  data_dict['df_charger'][['name', 'full_date', 'year', 'total']],
#                                  on=['name', 'full_date', 'year'])
#     df_ev_chg_merge['ev_per_charger'] = df_ev_chg_merge['car'] / df_ev_chg_merge['total']
#     df_ev_chg_merge = df_ev_chg_merge.replace([np.inf, -np.inf], np.nan).dropna(subset=['ev_per_charger'])
# 
#     latest_year_data = df_ev_chg_merge[df_ev_chg_merge['year'] == df_ev_chg_merge['year'].max()]
# 
#     regional_summary = latest_year_data.groupby('name').agg(
#         ev_counts=('car', 'sum'),
#         charger_counts=('total', 'sum'),
#         avg_ev_per_charger=('ev_per_charger', 'mean')
#     ).reset_index()
# 
#     regions = regional_summary['name'].tolist()
#     ev_counts = regional_summary['ev_counts'].tolist()
#     charger_counts = regional_summary['charger_counts'].tolist()
# 
#     colors = plt.cm.tab20.colors[:len(regions)]
# 
#     car_total_yearly = data_dict['df_car'].groupby('year')['car'].sum().reset_index()
#     charger_total_yearly = data_dict['df_charger'].groupby('year')['total'].sum().reset_index()
# 
#     df_total_yearly = pd.merge(car_total_yearly, charger_total_yearly, on='year')
#     df_total_yearly['car_thousands'] = df_total_yearly['car'] / 1000
#     df_total_yearly['charger_thousands'] = df_total_yearly['total'] / 1000
# 
#     years = df_total_yearly['year'].astype(str).tolist()
#     total_ev_yearly = df_total_yearly['car_thousands'].tolist()
#     total_charger_yearly = df_total_yearly['charger_thousands'].tolist()
# 
#     df_ev_allcar_merge = pd.merge(data_dict['df_car'][['name', 'full_date', 'year', 'car']],
#                                   data_dict['df_allcar'][['name', 'full_date', 'year', 'allcar']],
#                                   on=['name', 'full_date', 'year'])
#     df_ev_allcar_merge['ev_ratio'] = df_ev_allcar_merge['car'] / df_ev_allcar_merge['allcar'] * 100
#     df_ev_allcar_merge = df_ev_allcar_merge.replace([np.inf, -np.inf], np.nan).dropna(subset=['ev_ratio'])
# 
#     all_text = ' '.join(data_dict['df_crawling'].iloc[:, 0].dropna().astype(str))
#     okt = Okt()
#     nouns = okt.nouns(all_text)
# 
#     stopwords = set()
#     try:
#         with open(stopwords_path, 'r', encoding='utf-8') as f:
#             stopwords = set(word.strip() for word in f if word.strip())
#     except FileNotFoundError:
#         st.warning(f"Stopwords file '{stopwords_path}' not found. Word cloud will not filter stopwords.")
#     except Exception as e:
#         st.warning(f"Error loading stopwords: {e}. Word cloud will not filter stopwords.")
# 
#     filtered_nouns = [noun for noun in nouns if len(noun) > 1 and noun not in stopwords]
#     word_count = Counter(filtered_nouns)
# 
#     data_dict.update({
#         'regional_summary': regional_summary,
#         'regions': regions,
#         'ev_counts': ev_counts,
#         'charger_counts': charger_counts,
#         'colors': colors,
#         'years': years,
#         'total_ev_yearly': total_ev_yearly,
#         'total_charger_yearly': total_charger_yearly,
#         'df_ev_chg_merge': df_ev_chg_merge,
#         'df_ev_allcar_merge': df_ev_allcar_merge,
#         'word_count': word_count
#     })
#     return data_dict
# 
# @st.cache_data(ttl=3600)
# def load_charger_location_data(file_path='/content/ì „ê¸°ì°¨ì¶©ì „ì†Œ2.xlsx'):
#     """
#     ì¶©ì „ì†Œ ìœ„ì¹˜ ë°ì´í„° (ìœ„ë„, ê²½ë„)ë¥¼ ë¡œë“œí•˜ê³  ì „ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
#     """
#     start_time = time.time()
#     try:
#         df = pd.read_excel(file_path, engine='openpyxl', dtype_backend='pyarrow')
# 
#         required_columns = ['ìœ„ë„ê²½ë„', 'ì¶©ì „ì†Œëª…', 'ì£¼ì†Œ', 'ì‹œë„', 'êµ°êµ¬', 'ì„¤ì¹˜ë…„ë„']
#         existing_columns = [col for col in required_columns if col in df.columns]
#         df = df[existing_columns]
# 
#         if 'ìœ„ë„ê²½ë„' in df.columns:
#             df[['ìœ„ë„', 'ê²½ë„']] = df['ìœ„ë„ê²½ë„'].str.split(',', expand=True)
#             df['ìœ„ë„'] = pd.to_numeric(df['ìœ„ë„'], errors='coerce')
#             df['ê²½ë„'] = pd.to_numeric(df['ê²½ë„'], errors='coerce')
#         else:
#             st.error("Error: 'ìœ„ë„ê²½ë„' ì»¬ëŸ¼ì„ Excel íŒŒì¼ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
#             return pd.DataFrame()
# 
#         df['ì„¤ì¹˜ë…„ë„'] = pd.to_numeric(df['ì„¤ì¹˜ë…„ë„'], errors='coerce').astype('Int64')
# 
#         df_clean = df.dropna(subset=['ìœ„ë„', 'ê²½ë„', 'ì„¤ì¹˜ë…„ë„'])
# 
#         df_clean = df_clean[
#             (df_clean['ìœ„ë„'] >= 33.0) & (df_clean['ìœ„ë„'] <= 39.0) &
#             (df_clean['ê²½ë„'] >= 124.0) & (df_clean['ê²½ë„'] <= 132.0)
#         ].reset_index(drop=True)
# 
#         load_time = time.time() - start_time
#         #st.success(f"ì¶©ì „ì†Œ ìœ„ì¹˜ ë°ì´í„° ë¡œë“œ ì™„ë£Œ ({load_time:.2f}ì´ˆ, {len(df_clean):,}ê°œ ì¶©ì „ì†Œ)")
#         return df_clean
# 
#     except FileNotFoundError:
#         st.error(f"Error: '{file_path}' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Colab í™˜ê²½ì— ì—…ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
#         return pd.DataFrame()
#     except Exception as e:
#         st.error(f"ì¶©ì „ì†Œ ìœ„ì¹˜ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜: {e}")
#         return pd.DataFrame()
# 
# 
# # --- ì‚¬ì´ë“œë°” ë©”ë‰´ ---
# def render_sidebar():
#     """ì‚¬ì´ë“œë°” ë©”ë‰´ ë Œë”ë§"""
#     st.sidebar.title("ì¹´í…Œê³ ë¦¬")
# 
#     # ê°„ë‹¨í•œ CSS
#     st.markdown("""
#       <style>
#           /* ì‚¬ì´ë“œë°” ì»¨í…Œì´ë„ˆ íŒ¨ë”© ì¡°ì • */
#           section[data-testid="stSidebar"] > div {
#               padding-left: 1rem;
#               padding-right: 1rem;
#           }
# 
#           /* ì‚¬ì´ë“œë°” ë²„íŠ¼ ì „ì²´ ë„ˆë¹„ */
#           section[data-testid="stSidebar"] .stButton {
#               width: 100% !important;
#           }
# 
#           section[data-testid="stSidebar"] .stButton > button {
#               width: 100% !important;
#               text-align: left !important;
#               justify-content: flex-start !important;
#               padding: 0.5rem 1rem !important;
#               margin: 0.25rem 0 !important;
#               min-height: 2.5rem !important;
#               border-radius: 0.5rem !important;
#               background-color: #f0f2f6 !important;
#               border: 1px solid transparent !important;
#               transition: all 0.2s ease !important;
#           }
# 
#           /* ë²„íŠ¼ í˜¸ë²„ íš¨ê³¼ */
#           section[data-testid="stSidebar"] .stButton > button:hover {
#               background-color: #e6f3ff !important;
#               border-left: 3px solid #4ECDC4 !important;
#               padding-left: calc(1rem - 2px) !important;
#               transform: translateX(2px);
#           }
# 
#           /* ë²„íŠ¼ í´ë¦­(í™œì„±) ìƒíƒœ */
#           section[data-testid="stSidebar"] .stButton > button:active,
#           section[data-testid="stSidebar"] .stButton > button:focus {
#               background-color: #4ECDC4 !important;
#               color: white !important;
#               box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
#               outline: none !important;
#           }
# 
#           /* ë²„íŠ¼ ë‚´ë¶€ í…ìŠ¤íŠ¸ */
#           section[data-testid="stSidebar"] .stButton > button > div {
#               text-align: left !important;
#               width: 100% !important;
#           }
# 
#           section[data-testid="stSidebar"] .stButton > button p {
#               text-align: left !important;
#               margin: 0 !important;
#               font-weight: 500 !important;
#           }
# 
#           /* ì‚¬ì´ë“œë°” ì œëª© ìŠ¤íƒ€ì¼ */
#           section[data-testid="stSidebar"] h1 {
#               font-size: 1.5rem !important;
#               margin-bottom: 1.5rem !important;
#               padding-bottom: 0.5rem !important;
#               border-bottom: 2px solid #4ECDC4 !important;
#           }
#       </style>
#       """, unsafe_allow_html=True)
# 
#     if 'current_page' not in st.session_state:
#         st.session_state.current_page = "í‚¤ì›Œë“œ ë¶„ì„"
# 
#     pages = {
#         "ì£¼ìš” í† í”½": "menu_keywords",
#         "ì¶©ì „ì†Œ í˜„í™©": "menu_heatmap_new",
#         "ìƒê´€ë¶„ì„ê²°ê³¼": "menu_correlation",
#         "ì¸í”„ë¼ í˜„í™©": "menu_infrastructure",
#         "ë¶„ì„ ë¦¬í¬íŠ¸": "menu_conclusion",
#         "FAQ" : "menu_FAQ"
#     }
# 
#     for page, key in pages.items():
#         if st.sidebar.button(page, key=key):
#             st.session_state.current_page = page
# 
# # --- Plotting Functions ---
# 
# def create_pie_chart(data, title):
#     """íŒŒì´ ì°¨íŠ¸ ìƒì„±"""
#     fig, ax = plt.subplots(figsize=(8, 6))
#     wedges, texts, autotexts = ax.pie(
#         data['ev_counts'],
#         labels=data['regions'],
#         autopct='%1.1f%%',
#         startangle=90,
#         colors=data['colors']
#     )
#     ax.set_title(title, fontsize=14, pad=20)
#     plt.tight_layout()
#     return fig
# 
# def create_correlation_plot_regional(data):
#     """ì§€ì—­ë³„ ìƒê´€ê´€ê³„ ì‚°í¬ë„ ìƒì„± (ì „ê¸°ì°¨ ëŒ€ìˆ˜ vs ì¶©ì „ì†Œ ê°œìˆ˜)"""
#     fig, ax = plt.subplots(figsize=(10, 6))
# 
#     correlation = np.corrcoef(data['ev_counts'], data['charger_counts'])[0, 1]
# 
#     scatter = ax.scatter(data['ev_counts'], data['charger_counts'],
#                              c=data['colors'], s=150, alpha=0.7, edgecolors='black')
# 
#     z = np.polyfit(data['ev_counts'], data['charger_counts'], 1)
#     p = np.poly1d(z)
#     ax.plot(data['ev_counts'], p(data['ev_counts']), "r--", alpha=0.8, linewidth=2)
# 
#     for i, region in enumerate(data['regions']):
#         ax.annotate(region, (data['ev_counts'][i], data['charger_counts'][i]),
#                              xytext=(5, 5), textcoords='offset points', fontsize=10)
# 
#     ax.set_xlabel('ì „ê¸°ì°¨ ë“±ë¡ ëŒ€ìˆ˜')
#     ax.set_ylabel('ì¶©ì „ì†Œ ê°œìˆ˜')
#     ax.set_title(f'ì§€ì—­ë³„ ì „ê¸°ì°¨ vs ì¶©ì „ì†Œ ìƒê´€ê´€ê³„ (r = {correlation:.3f})')
#     ax.grid(True, alpha=0.3)
#     plt.tight_layout()
#     return fig, correlation
# 
# def create_time_series(data):
#     """ì—°ë„ë³„ ì „ê¸°ì°¨ ë° ì¶©ì „ì†Œ ì¦ê°€ ì¶”ì´ ì‹œê³„ì—´ ì°¨íŠ¸ ìƒì„±"""
#     fig, ax = plt.subplots(figsize=(10, 6))
#     ax2 = ax.twinx()
# 
#     line1 = ax.plot(data['years'], data['total_ev_yearly'], 'b-o', linewidth=3, label='ì „ê¸°ì°¨ (ì²œ ëŒ€)')
#     ax.set_ylabel('ì „ê¸°ì°¨ ë“±ë¡ëŒ€ìˆ˜ (ì²œ ëŒ€)', color='blue')
#     ax.tick_params(axis='y', labelcolor='blue')
# 
#     line2 = ax2.plot(data['years'], data['total_charger_yearly'], 'g-s', linewidth=3, label='ì¶©ì „ì†Œ (ì²œ ê°œ)')
#     ax2.set_ylabel('ì¶©ì „ì†Œ ê°œìˆ˜ (ì²œ ê°œ)', color='green')
#     ax2.tick_params(axis='y', labelcolor='green')
# 
#     ax.set_xlabel('ì—°ë„')
#     ax.set_title('ì „ê¸°ì°¨ ë° ì¶©ì „ì†Œ ì¦ê°€ ì¶”ì´')
#     ax.grid(True, alpha=0.3)
# 
#     lines = line1 + line2
#     labels = [l.get_label() for l in lines]
#     ax.legend(lines, labels, loc='upper left')
#     plt.tight_layout()
#     return fig
# 
# def plot_ev_per_charger_2024(df_merged_data):
#     st.header("2024ë…„ ì§€ì—­ë³„ ì¶©ì „ê¸°ë‹¹ ì „ê¸°ì°¨ ìˆ˜")
#     df_2024 = df_merged_data[df_merged_data['year'] == 2024]
#     if df_2024.empty:
#         st.warning("2024ë…„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
#         return
# 
#     df_bar = df_2024.groupby('name')['ev_per_charger'].mean().reset_index()
#     df_bar = df_bar.sort_values(by='ev_per_charger', ascending=False)
# 
#     fig, ax = plt.subplots(figsize=(12, 6))
#     bars = ax.bar(df_bar['name'], df_bar['ev_per_charger'], color='skyblue')
# 
#     for bar in bars:
#         height = bar.get_height()
#         ax.text(bar.get_x() + bar.get_width()/2, height + 0.3, f'{height:.1f}',
#                         ha='center', va='bottom', fontsize=9)
# 
#     ax.set_title("2024ë…„ ì§€ì—­ë³„ ì¶©ì „ê¸°ë‹¹ ì „ê¸°ì°¨ ìˆ˜", fontsize=14)
#     ax.set_xlabel("ì§€ì—­")
#     ax.set_ylabel("ì „ê¸°ì°¨ ëŒ€ìˆ˜ (ì¶©ì „ê¸° 1ê¸°ë‹¹)")
#     plt.xticks(rotation=45)
#     plt.tight_layout()
#     st.pyplot(fig)
#     plt.close(fig)
# 
# def plot_ev_per_charger_timeseries(df_merged_data):
#     st.header("ì§€ì—­ë³„ ì¶©ì „ê¸°ë‹¹ ì „ê¸°ì°¨ ìˆ˜ ë³€í™” ì¶”ì´")
#     df_grouped = df_merged_data.groupby(['full_date', 'name'])['ev_per_charger'].mean().reset_index()
#     pivot = df_grouped.pivot(index='full_date', columns='name', values='ev_per_charger')
# 
#     fig, ax = plt.subplots(figsize=(14, 7))
#     pivot.plot(marker='s', ax=ax)
#     ax.set_title("ì§€ì—­ë³„ ì¶©ì „ê¸°ë‹¹ ì „ê¸°ì°¨ ìˆ˜", fontsize=14)
#     ax.set_xlabel("ë‚ ì§œ")
#     ax.set_ylabel("ì „ê¸°ì°¨ ëŒ€ìˆ˜ (ì¶©ì „ê¸° 1ê¸°ë‹¹)")
#     ax.legend(title="ì§€ì—­", bbox_to_anchor=(1.05, 1), loc='upper left')
#     plt.grid(True)
#     plt.tight_layout()
#     st.pyplot(fig)
#     plt.close(fig)
# 
# def plot_ev_ratio_timeseries(df_merged_data):
#     st.header("ì§€ì—­ë³„ ì „ê¸°ì°¨ ë¹„ìœ¨ ë³€í™” ì¶”ì´")
#     df_grouped = df_merged_data.groupby(['full_date', 'name'])['ev_ratio'].mean().reset_index()
#     pivot = df_grouped.pivot(index='full_date', columns='name', values='ev_ratio')
# 
#     fig, ax = plt.subplots(figsize=(14, 7))
#     pivot.plot(marker='o', ax=ax)
#     ax.set_title("ì§€ì—­ë³„ ì „ê¸°ì°¨ ë¹„ìœ¨ ë³€í™” (%)", fontsize=14)
#     ax.set_xlabel("ë‚ ì§œ")
#     ax.set_ylabel("ì „ê¸°ì°¨ ë¹„ìœ¨ (%)")
#     ax.legend(title="ì§€ì—­", bbox_to_anchor=(1.05, 1), loc='upper left')
#     plt.grid(True)
#     plt.tight_layout()
#     st.pyplot(fig)
#     plt.close(fig)
# 
# def plot_car_charger_correlation_national(df_car_data, df_charger_data):
#     st.header("ì „êµ­ ì „ê¸°ì°¨ ìˆ˜ì™€ ì¶©ì „ê¸° ìˆ˜ ìƒê´€ê´€ê³„")
#     df_car_corr = df_car_data.copy()
#     df_charger_corr = df_charger_data.copy()
# 
#     df_car_corr['full_date'] = pd.to_datetime(df_car_corr['full_date'])
#     df_charger_corr['full_date'] = pd.to_datetime(df_charger_corr['full_date'])
# 
#     car_total = df_car_corr.groupby('full_date')['car'].sum().reset_index()
#     char_total = df_charger_corr.groupby('full_date')['total'].sum().reset_index()
# 
#     df_total = pd.merge(car_total, char_total, on='full_date')
#     df_total['car'] = df_total['car'] / 1000
#     df_total['total'] = df_total['total'] / 1000
# 
#     corr, p_value = pearsonr(df_total['car'], df_total['total'])
# 
#     st.write(f"**ì „ì²´ ê¸°ê°„ ì „ê¸°ì°¨ ìˆ˜ì™€ ì¶©ì „ê¸° ìˆ˜ í”¼ì–´ìŠ¨ ìƒê´€ê³„ìˆ˜:** `{corr:.4f}` (ìœ ì˜í™•ë¥ : `{p_value:.4f}`)")
# 
#     def thousands(x, pos):
#         return f'{int(x):,}'
# 
#     fig, ax = plt.subplots(figsize=(12, 6))
#     ax.plot(df_total['full_date'], df_total['car'], marker='o', label='ì „ê¸°ì°¨ ìˆ˜ (ì²œ ëŒ€)')
#     ax.plot(df_total['full_date'], df_total['total'], marker='x', linestyle='--', label='ì¶©ì „ê¸° ìˆ˜ (ì²œ ëŒ€)')
#     ax.set_xlabel("ë‚ ì§œ")
#     ax.set_ylabel("ëŒ€ìˆ˜ (ì²œ ë‹¨ìœ„)")
#     ax.set_title(f"ì „êµ­ ì „ê¸°ì°¨ ìˆ˜ vs ì¶©ì „ê¸° ìˆ˜\n(í”¼ì–´ìŠ¨ ìƒê´€ê³„ìˆ˜: {corr:.2f})", fontsize=14)
#     ax.legend()
#     ax.grid(True)
#     ax.yaxis.set_major_formatter(FuncFormatter(thousands))
# 
#     plt.tight_layout()
#     st.pyplot(fig)
#     plt.close(fig)
# 
#     st.subheader("ë³€í™”ëŸ‰ ê¸°ë°˜ ìƒê´€ê´€ê³„ ë¶„ì„")
#     df_total['car_diff'] = df_total['car'].diff()
#     df_total['total_diff'] = df_total['total'].diff()
#     df_diff = df_total.dropna(subset=['car_diff', 'total_diff'])
# 
#     if not df_diff.empty:
#         corr_diff, p_value_diff = pearsonr(df_diff['car_diff'], df_diff['total_diff'])
#         st.write(f"**ì›”ë³„ ì¦ê°€ëŸ‰ ê¸°ë°˜ í”¼ì–´ìŠ¨ ìƒê´€ê³„ìˆ˜:** `{corr_diff:.4f}` (ìœ ì˜í™•ë¥ : `{p_value_diff:.4f}`)")
#     else:
#         st.write("ë°ì´í„° ë¶€ì¡±ìœ¼ë¡œ ë³€í™”ëŸ‰ ê¸°ë°˜ ìƒê´€ê´€ê³„ë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
# 
# 
# # --- Main App Logic ---
# def main():
#     # --- í•œê¸€ í°íŠ¸ ì„¤ì • ---
#     font_path = '/usr/share/fonts/truetype/nanum/NanumGothic.ttf'
#     if 'font_installed' not in st.session_state:
#         try:
#             fm.findfont('NanumGothic', fallback_to_default=False)
#             plt.rcParams['font.family'] = 'NanumGothic'
#             plt.rcParams['axes.unicode_minus'] = False
#             st.session_state.font_installed = True
#             print("NanumGothic font already configured.")
#         except ValueError:
#             print("Installing NanumGothic font...")
#             try:
#                 st.info("ë‚˜ëˆ”ê³ ë”• í°íŠ¸ë¥¼ ì„¤ì¹˜ ì¤‘ì…ë‹ˆë‹¤. (Colab í™˜ê²½)")
#                 # Use subprocess.run for shell commands
#                 subprocess.run(['apt-get', 'update', '-qq'], check=True)
#                 subprocess.run(['apt-get', 'install', 'fonts-nanum', '-qq'], check=True)
#                 subprocess.run(['fc-cache', '-fv'], check=True)
#                 subprocess.run(['rm', '-rf', '~/.cache/matplotlib'], check=True)
# 
#                 plt.rcParams['font.family'] = 'NanumGothic'
#                 plt.rcParams['axes.unicode_minus'] = False
#                 st.session_state.font_installed = True
#                 st.success("ë‚˜ëˆ”ê³ ë”• í°íŠ¸ ì„¤ì¹˜ ë° ì„¤ì • ì™„ë£Œ.")
#             except subprocess.CalledProcessError as e:
#                 st.warning(f"ë‚˜ëˆ”ê³ ë”• í°íŠ¸ ì„¤ì¹˜ ì˜¤ë¥˜ (ì‰˜ ëª…ë ¹ ì‹¤í–‰ ì‹¤íŒ¨): {e}. ê·¸ë˜í”„ì— í•œê¸€ì´ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
#                 plt.rcParams['font.family'] = 'DejaVu Sans'
#                 plt.rcParams['axes.unicode_minus'] = False
#                 st.session_state.font_installed = False
#             except Exception as e:
#                 st.warning(f"ë‚˜ëˆ”ê³ ë”• í°íŠ¸ ì„¤ì¹˜ ë˜ëŠ” ì„¤ì • ì˜¤ë¥˜: {e}. ê·¸ë˜í”„ì— í•œê¸€ì´ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
#                 plt.rcParams['font.family'] = 'DejaVu Sans'
#                 plt.rcParams['axes.unicode_minus'] = False
#                 st.session_state.font_installed = False
#         except Exception as e:
#             st.warning(f"í°íŠ¸ ì„¤ì • í™•ì¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}. ê¸°ë³¸ í°íŠ¸ë¡œ í‘œì‹œë©ë‹ˆë‹¤.")
#             plt.rcParams['font.family'] = 'DejaVu Sans'
#             plt.rcParams['axes.unicode_minus'] = False
#             st.session_state.font_installed = False
# 
# 
#     with st.spinner("í•„ìˆ˜ ë°ì´í„°ë¥¼ ë¡œë“œ ì¤‘ì…ë‹ˆë‹¤..."):
#         common_data = load_common_data()
#     with st.spinner("ì¶©ì „ì†Œ ìœ„ì¹˜ ë°ì´í„°ë¥¼ ë¡œë“œ ì¤‘ì…ë‹ˆë‹¤..."):
#         charger_location_df = load_charger_location_data()
# 
#     render_sidebar()
# 
#     if st.session_state.current_page == "ì¶©ì „ì†Œ í˜„í™©":
#         st.title("ì „ê¸°ì°¨ ì¶©ì „ì†Œ í˜„í™© ëŒ€ì‹œë³´ë“œ")
#         st.markdown("---")
# 
#         col_main_map, col_right_panel_map = st.columns([4, 1])
# 
#         with col_right_panel_map:
#             st.subheader("ì§€ë„ ì„¤ì •")
# 
#             if not charger_location_df.empty:
#                 min_year = int(charger_location_df['ì„¤ì¹˜ë…„ë„'].min())
#                 max_year = int(charger_location_df['ì„¤ì¹˜ë…„ë„'].max())
#             else:
#                 min_year = 2010
#                 max_year = 2024
# 
#             # st.markdown("ì¶©ì „ì†Œ ì„¤ì¹˜ ì—°ë„")
#             year_range = st.slider(
#                 "ì„¤ì¹˜ ì—°ë„",
#                 min_value=min_year,
#                 max_value=max_year,
#                 value=(min_year, max_year),
#                 step=1,
#                 key="map_year_slider",
#                 label_visibility="hidden"
#             )
#             st.markdown("")
#             # st.markdown("ì§€ì—­ ì„ íƒ")
#             if not charger_location_df.empty and 'ì‹œë„' in charger_location_df.columns:
#                 regions = ['ì „ì²´'] + sorted(charger_location_df['ì‹œë„'].unique().tolist())
#             else:
#                 regions = ['ì „ì²´']
#             selected_region = st.selectbox("ì‹œë„ ì„ íƒ", regions, key="map_region_select")
#             st.markdown("")
# 
#             # st.markdown("ì§€ë„ ì˜µì…˜")
#             show_heatmap = st.checkbox("íˆíŠ¸ë§µ í‘œì‹œ", value=True, key="map_show_heatmap")
#             show_markers = st.checkbox("ë§ˆì»¤ í‘œì‹œ", value=False, key="map_show_markers")
# 
#             # st.markdown("íˆíŠ¸ë§µ ë°ì´í„° ê°œìˆ˜")
#             st.markdown("")
# 
#             heatmap_limit = 5000
#             if show_heatmap:
#                 heatmap_limit = st.slider(
#                     "ì¶©ì „ì†Œ ìˆ˜",
#                     min_value=1000,
#                     max_value=min(20000, len(charger_location_df) if not charger_location_df.empty else 10000),
#                     value=min(5000, len(charger_location_df) if not charger_location_df.empty else 5000),
#                     step=1000,
#                     help="ë” ì ì€ ìˆ˜ë¡œ ì„¤ì •í•˜ë©´ ì†ë„ê°€ í–¥ìƒë©ë‹ˆë‹¤",
#                     key="heatmap_limit_slider",
#                     # label_visibility="hidden"
#                 )
# 
#             marker_limit = 500
#             if show_markers:
#                 marker_limit = st.slider(
#                     "ì¶©ì „ì†Œ ìˆ˜",
#                     min_value=100,
#                     max_value=min(5000, len(charger_location_df) if not charger_location_df.empty else 2000),
#                     value=min(500, len(charger_location_df) if not charger_location_df.empty else 500),
#                     step=100,
#                     help="ë„ˆë¬´ ë§ì€ ë§ˆì»¤ëŠ” ì„±ëŠ¥ì„ ì €í•˜ì‹œí‚µë‹ˆë‹¤",
#                     key="marker_limit_slider",
#                     # label_visibility="hidden"
#                 )
# 
# 
#         with col_main_map:
#             col_map_stats_1, col_map_stats_2, col_map_stats_3 = st.columns(3)
# 
#             @st.cache_data
#             def filter_map_data(df, year_start, year_end, region):
#                 filtered_df = df[
#                     (df['ì„¤ì¹˜ë…„ë„'] >= year_start) &
#                     (df['ì„¤ì¹˜ë…„ë„'] <= year_end)
#                 ]
#                 if region != 'ì „ì²´':
#                     filtered_df = filtered_df[filtered_df['ì‹œë„'] == region]
#                 return filtered_df
# 
#             filtered_charger_df = filter_map_data(charger_location_df, year_range[0], year_range[1], selected_region)
# 
# 
#             with col_map_stats_1:
#                 st.metric("ì¶©ì „ì†Œ ìˆ˜", f"{len(filtered_charger_df):,}ê°œ")
# 
#             with col_map_stats_2:
#                 regions_count_map = filtered_charger_df['ì‹œë„'].nunique() if 'ì‹œë„' in filtered_charger_df.columns else 0
#                 st.metric("ì§€ì—­", f"{regions_count_map}ê°œ")
# 
#             with col_map_stats_3:
#                 if year_range[0] != year_range[1]:
#                     years_count_map = year_range[1] - year_range[0] + 1
#                     st.metric("ì„ íƒ ê¸°ê°„", f"{years_count_map}ë…„")
#                 else:
#                     st.metric("ì„ íƒ ì—°ë„", f"{year_range[0]}ë…„")
# 
#             st.markdown("---")
# 
#             if not filtered_charger_df.empty:
#                 if selected_region != 'ì „ì²´':
#                     center_lat = filtered_charger_df['ìœ„ë„'].mean()
#                     center_lon = filtered_charger_df['ê²½ë„'].mean()
#                     zoom_start = 9
#                 else:
#                     center_lat = 36.5
#                     center_lon = 127.5
#                     zoom_start = 7
# 
#                 map_start_time = time.time()
# 
#                 with st.spinner("ì§€ë„ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘..."):
#                     m = folium.Map(
#                         location=[center_lat, center_lon],
#                         zoom_start=zoom_start,
#                         tiles='OpenStreetMap'
#                     )
# 
#                     if show_heatmap:
#                         heat_sample = filtered_charger_df.sample(n=min(len(filtered_charger_df), heatmap_limit), random_state=42)
#                         heat_data = heat_sample[['ìœ„ë„', 'ê²½ë„']].values.tolist()
# 
#                         plugins.HeatMap(
#                             heat_data,
#                             radius=15,
#                             blur=15,
#                             max_zoom=13,
#                             gradient={0.2: 'blue', 0.4: 'lime', 0.6: 'yellow', 0.8: 'orange', 1: 'red'}
#                         ).add_to(m)
#                         if len(filtered_charger_df) > heatmap_limit:
#                             st.info(f"ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ íˆíŠ¸ë§µì— {heatmap_limit:,}ê°œ ì§€ì ë§Œ í‘œì‹œë©ë‹ˆë‹¤.")
# 
# 
#                     if show_markers:
#                         marker_cluster = plugins.MarkerCluster(
#                             maxClusterRadius=50,
#                             disableClusteringAtZoom=10
#                         ).add_to(m)
# 
#                         marker_sample = filtered_charger_df.sample(n=min(len(filtered_charger_df), marker_limit), random_state=42)
# 
#                         for idx, row in marker_sample.iterrows():
#                             folium.Marker(
#                                 location=[row['ìœ„ë„'], row['ê²½ë„']],
#                                 popup=folium.Popup(
#                                     f"<b>{row['ì¶©ì „ì†Œëª…']}</b><br>{row['ì£¼ì†Œ']}<br>ì„¤ì¹˜ë…„ë„: {int(row['ì„¤ì¹˜ë…„ë„'])}",
#                                     max_width=300
#                                 ),
#                                 icon=folium.Icon(color='blue', icon='plug', prefix='fa')
#                             ).add_to(marker_cluster)
#                         if len(filtered_charger_df) > marker_limit:
#                             st.info(f"ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ë§ˆì»¤ëŠ” {marker_limit:,}ê°œë§Œ í‘œì‹œë©ë‹ˆë‹¤.")
# 
# 
#                 map_time = time.time() - map_start_time
# 
#                 tab1, tab2, tab3 = st.tabs(["ì¶©ì „ì†Œ ì§€ë„", "ì—°ë„ë³„ ë¶„ì„", "ì‹œë„ë³„ ë¶„ì„"])
# 
#                 with tab1:
#                     st.subheader("ì¶©ì „ì†Œ ìœ„ì¹˜ ì§€ë„")
#                     st.markdown("")
#                     # st.caption(f"ì§€ë„ ìƒì„± ì‹œê°„: {map_time:.2f}ì´ˆ")
#                     st_folium(m, width=900, height=600, returned_objects=["last_object_clicked"])
# 
#                 with tab2:
#                     if not filtered_charger_df.empty:
#                         st.subheader("ì—°ë„ë³„ ì¶©ì „ì†Œ ì„¤ì¹˜ í˜„í™©")
#                         st.markdown("")
#                         year_trend = filtered_charger_df['ì„¤ì¹˜ë…„ë„'].value_counts().sort_index()
#                         year_trend_df = year_trend.reset_index()
#                         year_trend_df.columns = ['ì„¤ì¹˜ë…„ë„', 'ì¶©ì „ì†Œ ìˆ˜']
#                         # st.line_chart(year_trend_df.set_index('ì„¤ì¹˜ë…„ë„'))
#                         fig, ax = plt.subplots(figsize=(6,4))
#                         ax.plot(year_trend_df['ì„¤ì¹˜ë…„ë„'], year_trend_df['ì¶©ì „ì†Œ ìˆ˜'],
#                                 marker='o', linewidth=2, markersize=6)
#                         ax.set_xlabel('ì„¤ì¹˜ë…„ë„')
#                         ax.set_ylabel('ì¶©ì „ì†Œ ìˆ˜')
#                         ax.grid(True, alpha=0.3)
#                         plt.tight_layout()
#                         st.pyplot(fig, use_container_width=False)
#                         plt.close(fig)
#                     else:
#                         st.warning("ì‹œë„ë³„ ì¶©ì „ì†Œ í˜„í™©ì„ í‘œì‹œí•  ì§€ì—­ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.")
# 
#                 with tab3:
#                     # st.subheader("ìƒì„¸ ë¶„ì„ ë³´ê¸°")
#                     if not filtered_charger_df.empty:
#                         st.subheader("ì‹œë„ë³„ ì¶©ì „ì†Œ í˜„í™© (TOP 10)")
#                         st.markdown("")
#                         if 'ì‹œë„' in filtered_charger_df.columns:
#                             region_chart = filtered_charger_df['ì‹œë„'].value_counts().head(10)
# 
#                             fig, ax = plt.subplots(figsize=(6,4))
# 
#                             bars = ax.bar(region_chart.index, region_chart.values,
#                                             color='skyblue', edgecolor='navy', alpha=0.7)
# 
#                             ax.set_xlabel('ì‹œë„')
#                             ax.set_ylabel('ì¶©ì „ì†Œ ìˆ˜')
#                             ax.set_title('ì‹œë„ë³„ ì¶©ì „ì†Œ í˜„í™©')
# 
#                             for bar in bars:
#                                 height = bar.get_height()
#                                 ax.text(bar.get_x() + bar.get_width()/2., height,
#                                         f'{int(height)}',
#                                         ha='center', va='bottom')
# 
#                             plt.xticks(rotation=0)
#                             plt.tight_layout()
#                             st.pyplot(fig, use_container_width=False)
#                             plt.close(fig)
#                         else:
#                             st.warning("ì‹œë„ë³„ ì¶©ì „ì†Œ í˜„í™©ì„ í‘œì‹œí•  ì§€ì—­ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.")
# 
#             else:
#                 st.warning("ì„ íƒí•œ ì¡°ê±´ì— í•´ë‹¹í•˜ëŠ” ì¶©ì „ì†Œê°€ ì—†ìŠµë‹ˆë‹¤. í•„í„° ì¡°ê±´ì„ ì¡°ì •í•´ì£¼ì„¸ìš”.")
# 
# 
#     elif st.session_state.current_page == "ì£¼ìš” í† í”½":
#         st.header("ì»¤ë®¤ë‹ˆí‹° ë‚´ ì „ê¸°ì°¨ ê´€ë ¨ ì£¼ìš” í‚¤ì›Œë“œ ë¶„ì„")
#         st.write("**2020ë…„ ~ 2024ë…„, ë³´ë°°ë“œë¦¼ ê²Œì‹œê¸€**")
#         st.markdown("---")
#         st.markdown("""
#         <div style="text-align: right; margin-top: -20px; margin-bottom: 20px;">
#             <small style="color: #666;">
#                 ì¶œì²˜ : 2020ë…„ ~ 2024ë…„, ë³´ë°°ë“œë¦¼
#             </small>
#         </div>
#         """, unsafe_allow_html=True)
# 
#         if not common_data['word_count']:
#             st.warning("ì›Œë“œí´ë¼ìš°ë“œë¥¼ ìƒì„±í•  í‚¤ì›Œë“œ ë°ì´í„°ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. 'ele_crawling.csv' íŒŒì¼ê³¼ ë‚´ìš©ì„ í™•ì¸í•´ì£¼ì„¸ìš”.")
#         else:
# 
#             col1, col2, col3 = st.columns(3)
#             with col1:
#                 top_word = common_data['word_count'].most_common(1)[0][0]
#                 st.metric(label="ì¸ê¸° ë‹¨ì–´", value=top_word, delta="1ìœ„")
#             with col2:
#                 top_count = common_data['word_count'].most_common(1)[0][1]
#                 st.metric(label="ì–¸ê¸‰ ìˆ˜", value=f"{top_count}ë²ˆ", delta="ìµœê³ ")
#             with col3:
#                 total_keywords = len(common_data['word_count'])
#                 st.metric(label="ì´ ë‹¨ì–´", value=f"{total_keywords}ê°œ", delta="ê³ ìœ  ë‹¨ì–´")
# 
#             try:
#                 def create_circle_mask(size):
#                     y, x = np.ogrid[:size, :size]
#                     center = size / 2
#                     mask = (x - center) ** 2 + (y - center) ** 2 > (size/2) ** 2
#                     return mask.astype(int) * 255
# 
#                 mask = create_circle_mask(600)
# 
#                 wordcloud = WordCloud(width=1200,
#                                       height=800,
#                                       background_color='white',
#                                       font_path=font_path,
#                                       mask=mask,
#                                       collocations=False,
#                                       colormap='YlGnBu',
#                                       min_font_size=15,
#                                       max_font_size=100,
#                                       max_words=150,
#                                       relative_scaling=0.4
#                                       ).generate_from_frequencies(common_data['word_count'])
#                 fig, ax = plt.subplots(figsize=(5,5), dpi=300)
#                 ax.imshow(wordcloud, interpolation='bilinear')
#                 ax.axis('off')
#                 col_center = st.columns([1, 1.5, 1])
#                 with col_center[1]:
#                     st.pyplot(fig, dpi=300)
#                 plt.close(fig)
#             except Exception as e:
#                 st.error(f"ì›Œë“œí´ë¼ìš°ë“œ ìƒì„± ì˜¤ë¥˜: {e}. 'konlpy' ì„¤ì¹˜ ë° í•œê¸€ í°íŠ¸(ë‚˜ëˆ”ê³ ë”•) ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.")
# 
#     elif st.session_state.current_page == "ì¸í”„ë¼ í˜„í™©":
#         st.header("ì¸í”„ë¼ í˜„í™© ë¶„ì„")
# 
#         tab1, tab2, tab3, tab4 = st.tabs(["(2024ë…„) ì§€ì—­ë³„ ì „ê¸°ì°¨ ë¶„í¬", "ì§€ì—­ë³„ EV ë¹„ìœ¨", "(2024ë…„) ì§€ì—­ë³„ ì¶©ì „ê¸°ë‹¹ EV", "ì§€ì—­ë³„ ì¶©ì „ê¸°ë‹¹ EV"])
# 
#         with tab1:
#             st.subheader("ì§€ì—­ë³„ ì „ê¸°ì°¨ ë° ì¶©ì „ì†Œ ê²Œì´ì§€ë„ë„›")
# 
#             diagnosis_df = common_data['regional_summary'].copy()
#             diagnosis_df.rename(columns={
#                 'name': 'ì§€ì—­',
#                 'ev_counts': 'ì „ê¸°ì°¨ë“±ë¡ìˆ˜',
#                 'charger_counts': 'ì¶©ì „ê¸°ìˆ˜'
#             }, inplace=True)
# 
#             ev_list = diagnosis_df["ì „ê¸°ì°¨ë“±ë¡ìˆ˜"].tolist()
#             ch_list = diagnosis_df["ì¶©ì „ê¸°ìˆ˜"].tolist()
#             viz_data = list(zip(diagnosis_df["ì§€ì—­"], ev_list, ch_list))
# 
#             max_ev = max(ev_list) * 1.0
#             max_ch = max(ch_list) * 1.0
# 
#             fig, axs = plt.subplots(1, len(viz_data), figsize=(len(viz_data)*2.6, 3.5), constrained_layout=True)
#             if len(viz_data) == 1:
#                 axs = [axs]
# 
#             for ax, (region, ev, ch) in zip(axs, viz_data):
#                 ax.set_aspect("equal")
#                 ax.set_xlim(-1.2, 1.2)
#                 ax.set_ylim(-1.2, 1.2)
#                 ax.axis("off")
# 
#                 ev_theta = (ev / max_ev) * 270
#                 ch_theta = (ch / max_ch) * 270
# 
#                 ax.add_patch(patches.Wedge(
#                     center=(0, 0), r=1.0, theta1=135, theta2=135 + ev_theta,
#                     width=0.22, facecolor="#4F81BD", alpha=0.9
#                 ))
#                 ax.add_patch(patches.Wedge(
#                     center=(0, 0), r=0.7, theta1=135, theta2=135 + ch_theta,
#                     width=0.22, facecolor="#C0504D", alpha=0.85
#                 ))
# 
#                 ax.text(0, -1.1, region, ha='center', fontsize=10, weight='bold')
#                 ax.text(0, -1.3, f"EV: {ev:,}", ha='center', fontsize=9, color="#4F81BD")
#                 ax.text(0, -1.45, f"ì¶©ì „ì†Œ: {ch:,}", ha='center', fontsize=9, color="#C0504D")
# 
#             st.pyplot(fig)
#             plt.close(fig)
# 
#             df_regional_display = common_data['regional_summary'].copy()
#             df_regional_display['ì „ê¸°ì°¨ë‹¹ ì¶©ì „ì†Œ'] = np.round(df_regional_display['charger_counts'] / df_regional_display['ev_counts'], 3)
#             df_regional_display.rename(columns={
#                 'name': 'ì§€ì—­',
#                 'ev_counts': 'ì „ê¸°ì°¨ (ëŒ€)',
#                 'charger_counts': 'ì¶©ì „ì†Œ (ê°œ)',
#                 'avg_ev_per_charger': 'ì¶©ì „ê¸° 1ê¸°ë‹¹ EV (í‰ê· )'
#             }, inplace=True)
#             st.dataframe(df_regional_display, use_container_width=True)
# 
# 
#         with tab3:
#             plot_ev_per_charger_2024(common_data['df_ev_chg_merge'])
# 
#         with tab4:
#             plot_ev_per_charger_timeseries(common_data['df_ev_chg_merge'])
# 
#             # 'ê²½ê¸°'ë¥¼ ì œì™¸í•œ ë°ì´í„°ë§Œ í•„í„°ë§
#             filtered_df = common_data['df_ev_chg_merge'][common_data['df_ev_chg_merge']['name'] != 'ê²½ê¸°']
#             # í•„í„°ë§ëœ ë°ì´í„°ë¡œ ê·¸ë˜í”„ ì¶œë ¥
#             st.markdown("---")
#             st.subheader("íŠ¹ì´ê°’(ê²½ê¸°) ì œì™¸")
#             plot_ev_per_charger_timeseries(filtered_df)
# 
# 
#         with tab2:
#             plot_ev_ratio_timeseries(common_data['df_ev_allcar_merge'])
# 
#             # 'ì œì£¼'ë¥¼ ì œì™¸í•œ ë°ì´í„°ë§Œ í•„í„°ë§
#             filtered_df = common_data['df_ev_allcar_merge'][common_data['df_ev_allcar_merge']['name'] != 'ì œì£¼']
#             # í•„í„°ë§ëœ ë°ì´í„°ë¡œ ê·¸ë˜í”„ ì¶œë ¥
#             st.markdown("---")
#             st.subheader("íŠ¹ì´ê°’(ì œì£¼) ì œì™¸")
#             plot_ev_ratio_timeseries(filtered_df)
# 
# 
# 
# 
#     elif st.session_state.current_page == "ìƒê´€ë¶„ì„ê²°ê³¼":
#         st.header("ìƒê´€ê´€ê³„ ë¶„ì„")
#         plot_car_charger_correlation_national(common_data['df_car'], common_data['df_charger'])
#         st.markdown("---")
#         st.subheader("ì§€ì—­ë³„ ì „ê¸°ì°¨ vs ì¶©ì „ì†Œ ìƒê´€ê´€ê³„ (ìµœì‹  ë°ì´í„°)")
#         fig, correlation_regional = create_correlation_plot_regional(common_data)
#         st.pyplot(fig)
#         plt.close(fig)
#         col1, col2, col3 = st.columns(3)
#         with col1:
#             st.metric("ìƒê´€ê³„ìˆ˜ (ì§€ì—­ë³„)", f"{correlation_regional:.3f}")
#         with col2:
#             st.metric("ê²°ì •ê³„ìˆ˜ (ì§€ì—­ë³„)", f"{correlation_regional**2:.3f}")
#         with col3:
#             st.metric("í•´ì„", "ê°•í•œ ì–‘ì˜ ìƒê´€ê´€ê³„" if correlation_regional > 0.7 else ("ìŒì˜ ìƒê´€ê´€ê³„" if correlation_regional < -0.3 else "ì•½í•œ ìƒê´€ê´€ê³„"))
# 
#         st.markdown("---")
# 
# 
# 
#     elif st.session_state.current_page == "ë¶„ì„ ë¦¬í¬íŠ¸":
#         st.header("ì¶©ì „ìŠ¤íŠ¸ë ˆìŠ¤")
#         st.write("ê° ì§€ì—­ì˜ ì „ê¸°ì°¨ ìˆ˜ì™€ ì¶©ì „ì†Œ ìˆ˜ë¥¼ ë¹„êµí•˜ì—¬ ì¶©ì „ ìŠ¤íŠ¸ë ˆìŠ¤ ì •ë„ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.")
# 
#         scores = []
#         recommendations = []
#         if not common_data['regional_summary'].empty:
#             max_ev_per_charger_val = common_data['regional_summary']['avg_ev_per_charger'].max()
#             min_ev_per_charger_val = common_data['regional_summary']['avg_ev_per_charger'].min()
# 
#             for idx, row in common_data['regional_summary'].iterrows():
#                 ev_per_charger = row['avg_ev_per_charger']
#                 if pd.isna(ev_per_charger) or ev_per_charger == 0:
#                     score = 0
#                 elif max_ev_per_charger_val == min_ev_per_charger_val:
#                     score = 50
#                 else:
#                     score = ((max_ev_per_charger_val - ev_per_charger) / (max_ev_per_charger_val - min_ev_per_charger_val)) * 100
# 
#                 scores.append(round(score))
# 
#                 if score >= 70:
#                     recommendations.append("ğŸŸ¢ ë‚®ìŒ ")
#                 elif score >= 50:
#                     recommendations.append("ğŸŸ¡ ë³´í†µ ")
#                 elif score >= 30:
#                     recommendations.append("ğŸŸ  ë†’ìŒ ")
#                 else:
#                     recommendations.append("ğŸ”´ ë§¤ìš° ë†’ìŒ ")
# 
#         result_df = pd.DataFrame({
#             'ì§€ì—­': common_data['regions'],
#             'ì „ê¸°ì°¨ ìˆ˜': common_data['ev_counts'],
#             'ì¶©ì „ì†Œ ìˆ˜': common_data['charger_counts'],
#             'ì¶©ì „ê¸° 1ê¸°ë‹¹ ì „ê¸°ì°¨': common_data['regional_summary']['avg_ev_per_charger'].round(1).tolist(),
#             'ì¸í”„ë¼ ì ìˆ˜': scores,
#             'ì¶©ì „ ìŠ¤íŠ¸ë ˆìŠ¤': recommendations
#          })
# 
#         st.dataframe(result_df.sort_values(by='ì¸í”„ë¼ ì ìˆ˜', ascending=False),
#                      use_container_width=True,
#                      hide_index=True
#                      )
#         st.markdown("")
#         fig, ax = plt.subplots(figsize=(10, 6))
# 
#         # ë°ì´í„° ì •ë ¬
#         sorted_df = result_df.sort_values(by='ì¸í”„ë¼ ì ìˆ˜', ascending=True)  # ì°¨íŠ¸ìš©ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ
# 
#         # ë°” ì°¨íŠ¸ ê·¸ë¦¬ê¸°
#         bars = ax.bar(sorted_df['ì§€ì—­'], sorted_df['ì¸í”„ë¼ ì ìˆ˜'],
#                       color='skyblue', edgecolor='navy', alpha=0.7)
# 
#         # ê° ë°” ìœ„ì— ì ìˆ˜ í‘œì‹œ
#         for bar in bars:
#             height = bar.get_height()
#             ax.text(bar.get_x() + bar.get_width()/2., height + 1,
#                     f'{int(height)}',
#                     ha='center', va='bottom', fontweight='bold')
# 
#         ax.set_xlabel('ì§€ì—­')
#         ax.set_ylabel('ì¸í”„ë¼ ì ìˆ˜')
#         ax.set_title('ì§€ì—­ë³„ ì¸í”„ë¼ ì ìˆ˜')
#         ax.grid(True, alpha=0.3, axis='y')
# 
#         # ğŸ”§ xì¶• ê¸€ì ê°€ë¡œë¡œ ì„¤ì •
#         plt.xticks(rotation=0)  # 0ë„ = ê°€ë¡œ
#         plt.tight_layout()
# 
#         st.pyplot(fig)
#         plt.close(fig)
#          # st.info("ğŸ’¡ ì¶”ì²œ ì ìˆ˜ëŠ” í•´ë‹¹ ì§€ì—­ì˜ ì „ê¸°ì°¨ ìˆ˜ ëŒ€ë¹„ ì¶©ì „ì†Œ ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°ë©ë‹ˆë‹¤. ì ìˆ˜ê°€ ë†’ì„ìˆ˜ë¡ ì „ê¸°ì°¨ ì¶©ì „ ì¸í”„ë¼ í™˜ê²½ì´ ë” ë‚˜ì˜ë‹¤ê³  í•´ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
# 
#     elif st.session_state.current_page == "FAQ":
#       st.header("ì „ê¸°ì°¨ FAQ ê²€ìƒ‰")
# 
#       col1, col2 = st.columns([4, 1])
# 
#       with col1:
#           search_query = st.text_input(
#               "ê²€ìƒ‰ì–´ ì…ë ¥",
#               label_visibility="collapsed"
#           )
#       with col2:
#           search_button = st.button("ê²€ìƒ‰", type="primary", use_container_width=True)
# 
#       # ğŸ”¹ 2. íŒŒì¼ ê²½ë¡œ ì§€ì •
#       csv_path = "/content/crawling_car.csv"
#       df = pd.read_csv(csv_path, encoding='cp949')  # ì§ˆë¬¸, ë‹µë³€ ì»¬ëŸ¼ ì¡´ì¬ ê°€ì •
# 
#       # ğŸ”¹ 3. ëœë¤ ë‚ ì§œ ìƒì„± í•¨ìˆ˜
#       def random_date(start, end):
#           delta = end - start
#           random_days = random.randint(0, delta.days)
#           return (start + timedelta(days=random_days)).strftime('%Y-%m-%d')
# 
#       # ğŸ”¹ 4. ë‚ ì§œ ë²”ìœ„ ë° ì¶œì²˜ ë¦¬ìŠ¤íŠ¸ ì„¤ì •
#       start_date = datetime.strptime("2023-01-01", "%Y-%m-%d")
#       end_date = datetime.strptime("2024-12-31", "%Y-%m-%d")
#       sources = ["ê¸°ì•„", "í˜„ëŒ€", "í…ŒìŠ¬ë¼"]
# 
#       # ğŸ”¹ 5. FAQ ë°ì´í„° ë¦¬ìŠ¤íŠ¸ ìƒì„±
#       faq_data = []
#       for _, row in df.iterrows():
#           item = {
#               "category": "ì „ê¸°ì°¨",
#               "question": row["question"],
#               "answer": row["answer"],
#               "source": random.choice(sources),
#               "date": random_date(start_date, end_date),
#               "views": random.randint(100, 5000)
#           }
#           faq_data.append(item)
# 
#       # ğŸ”¹ 6. ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§
#       if search_query:
#           filtered_faq = [
#               faq for faq in faq_data
#               if search_query.lower() in faq['question'].lower() or
#                 search_query.lower() in faq['answer'].lower() or
#                 search_query.lower() in faq['category'].lower()
#           ]
#       else:
#           filtered_faq = faq_data
# 
#       # ğŸ”¹ 7. ê²€ìƒ‰ ê²°ê³¼ ê°œìˆ˜ í‘œì‹œ
#       st.metric("ê²€ìƒ‰ ê²°ê³¼", f"{len(filtered_faq)}ê±´")
#       st.markdown("---")
# 
#       # ğŸ”¹ 8. FAQ ì¶œë ¥
#       if len(filtered_faq) == 0:
#           st.info("ğŸ” ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ë³´ì„¸ìš”.")
#       else:
#           for i in range(0, len(filtered_faq), 2):
#               cols = st.columns(2)
#               for j in range(2):
#                   faq_index = i + j  # ğŸ”‘ ìœ ì¼í•œ ì¸ë±ìŠ¤ë¡œ í‚¤ ìƒì„±
#                   if faq_index < len(filtered_faq):
#                       faq = filtered_faq[faq_index]
#                       with cols[j]:
#                           with st.container():
#                               st.markdown(
#                                   f"""
#                                   <div style="
#                                       background-color: #f8f9fa;
#                                       padding: 20px;
#                                       border-radius: 10px;
#                                       border-left: 4px solid #4ECDC4;
#                                       margin-bottom: 10px;
#                                       height: 220px;
#                                   ">
#                                       <span style="
#                                           background-color: #4ECDC4;
#                                           color: white;
#                                           padding: 2px 8px;
#                                           border-radius: 4px;
#                                           font-size: 12px;
#                                       ">{faq['category']}</span>
#                                       <h4 style="margin-top: 10px; color: #2c3e50; font-size: 16px;">
#                                           {faq['question']}
#                                       </h4>
#                                       <p style="color: #555; margin: 10px 0; font-size: 14px;">
#                                           {str(faq['answer'])[:100]}...
#                                       </p>
#                                       <div style="
#                                           display: flex;
#                                           justify-content: space-between;
#                                           align-items: center;
#                                           margin-top: 15px;
#                                           font-size: 12px;
#                                           color: #888;
#                                       ">
#                                           <span>ğŸ“° {faq['source']}</span>
#                                           <span>ğŸ‘ï¸ {faq['views']:,}íšŒ</span>
#                                       </div>
#                                   </div>
#                                   """,
#                                   unsafe_allow_html=True
#                               )
# 
#                               if st.button("ìì„¸íˆ ë³´ê¸°", key=f"detail_{faq_index}", use_container_width=True):
#                                   with st.expander("ì „ì²´ ë‹µë³€", expanded=True):
#                                       st.write(f"**Q. {faq['question']}**")
#                                       st.write(faq['answer'])
#                                       st.caption(f"ì¶œì²˜: {faq['source']} | ì‘ì„±ì¼: {faq['date']}")
# 
# 
#     st.markdown("---")
# 
# if __name__ == "__main__":
#     main()

!wget -q -O - ipv4.icanhazip.com

!streamlit run app.py & npx localtunnel --port 8501

